---
layout: post
title: 你必须知道的.NET(第二版)
description: 一本介绍.NET核心技术的书，注：不太适合新手阅读
category: blog
subtype: read  
---

## 你必须知道的.NET-读书笔记
* 对象分为`值类型`和`引用类型`两种，其依据是对象在运行时在内存中的位置，值类型位于线程的`堆栈`，而引用类型位于`托管堆`。

* 值类型与引用类型的转变分别叫`装箱`和`拆箱`。

* 访问修饰符  

  | 访问修饰符 | 访问权限  
  | :- | :-  
  | public | 对访问成员没有限制，属于最高级别访问权限  
  | protected | 访问包含类或者从包含类派生的类  
  | internal | 访问仅限于程序集  
  | protected internal | 访问仅限于从包含类派生的当前程序集或类型。也就是同一个程序集的对象，或者该类及其子类可以访问  
  | private | 访问仅限于包含类型  

* 对象中的多态主要有以下两种情况  
  1. 接口实现多态  
  2. 抽象类实现多态  

* 继承，就是面向对象中类与类之间的关系。继承的类称为子类、派生类，而被继承类称为父类、基类或超类。通过继承，使得子类具有父类的属性和方法，同时子类也可以通过加入新的属性和方法或修改父类的属性和方法建立新的类层次。CLR支持实现单继承和接口多继承。  

* 继承的本质  
  1. 继承是可传递的，子类是对父类的扩展，必须继承父类方法，同时可以添加新方法  
  2. 子类可以调用父类方法和字段，而父类不能调用子类方法和字段  
  3. 虚方法如何实现覆写操作，使得父类指针可以指向子类对象成员
  4. 子类不光继承父类的公有成员，同时继承了父类的私有成员，只是在子类中不被访问  
  5. new 关键字在虚方法继承中的阻断作用  
   
* 抽象类与接口的对比  
  1. 抽象类适合于有族层概念的类间关系，而接口最适合为不同的类提供通用功能  
  2. 接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系  
  3. 接口多定义对象的行为；抽象类多定义对象的属性  
  4. 如果预计会出现版本问题，可以创建“抽象类”  
  5. 因为值类型是密封的，所以只能实现接口，而不能继承类  

* 继承的毒瘤主要体现在  
  1. 继承可能造成子类的无限膨胀，不利于类体系的维护和安全  
  2. 继承的子类对象确定于编译期，无法满足需要运行期才确定的情况，而类聚合很好地解决了这一问题  
  3. 随着继承层次的复杂化和子类的多样化，不可避免地会出现对父类的无效继承或者有害继承


* 继承的规则  
  1. 密封类不可以被继承  
  2. 继承关系中，我们更多的是关注其共性而不是特性，因为共性是层次复用的基础，而特性是系统扩展的基点  
  3. 实现单继承，接口多继承  
  4. 从宏观来看，继承多关注于共性；而多态多着眼于差异性  
  5. 继承的层次应该有所控制，否则类型之间的关系继护会消耗更多的精力  
  6. 面向对象原则：多组合，少继承；低耦合，高内聚  

* 封装隐藏了类内部的具体实现细节，对外则提供统一访问接口，来操作内部数据成员  
* 字段通常定义为private,表示类的状态信息  
* 属性通常定义为public,表示类的对外成员  
* 方法封装了类的行为，提供了类的对外表现  

* 封装的意义  
  1. 隐藏系统实现的细节，保证系统的安全性和可靠性  
  2. 提供稳定不变的对外接口  
  3. 封装保证了代码模块化，提高了软件的利用和功能分离  
   
* 封装的规则  
  1. 尽可能地调用类的访问器，而不是成员，即使在类的内部  
  2. 内部私有部分可以任意更改，但是一定要在保证外部接口稳定的前提下  
  3. 将对字段的读写控制实现为属性，而不是方法，否则舍近求远，非明智之选  
  4. 类封装是由访问权限来保证的，对内实现为private,对外实现为public,再结合继承特性，还要对protected,internal有较深的理解  
  5. 封装的精华是封装变化  
   
* 封装就是一个包装，将包装的内外分为两个空间，对内实现数据私有，对外实现方法调用，保证了数据的完整性和安全性  

* 多态指同一操作作用于不同的实例，产生不同运行结果的机制  
* 多态按实现方式分为`基类继承式多态`和`接口实现式多态`  

* 多态的规则和意义  
  1. 多态提供了对同一类对象的差异化处理方式，实现了对变化和共性的有效封装和继承，体现了“一个接口，多种方法”的思想，使方法抽象机制成为可能  
  2. 在.NET中，默认情况下方法是非虚的，以C#为例必须显式地通过virtual或者abstract标记虚方法或抽象方法，以便在子类中覆写父类方法  
  3. 在面向对象的基本要素中，多态和继承、多态和重载存在紧密的联系，正如前文所述多态的基础就是建立有效的继承体系，因此继承和重载是多态的实现基础  

* 所谓接口，就是契约，用于规定一种规则由大家遵守
* 接口规则  
  1. 接口隔离原则强调接口应该被实现为具有单一功能的小接口，而不要实现为具有多个功能的胖接口，类对于类的依赖应建立在最小的接口之上  
  2. 接口支持多继承，既可以作用于值类型，也可以作用于引用类型  
  3. 禁止为已经发布的接口，添加新的成员，这意味着你必须重新修改所有实现了该接口的类型  
  4. 接口不能被实例化，没有构造函数，接口成员被隐式声明为public  

---  

* 设计原则  
  | 设计原则 | 英文表达 | 说明  
  | :- | :- | :-  
  | 单一职责原则 | SRP，Single Responsiblity Principle | 一个类，应该仅有一个引起它变化的原因，不要将变化原因不同的职责封装在一起，而应该分离  
  | 开放封闭原则 | OCP，Open Closed Principle | 软件实体应当对修改关闭，对扩展开放  
  | 依赖倒置原则 | DIP，Dependency Inversion Priciple | 依赖于抽象，而不要依赖于具体，因为抽象相对稳定  
  | 接口隔离原则 | ISP，Interface Inversion Priciple | 尽量应用专门的接口，而不是单一的总接口，接口应该面向用户，将依赖建立在最小的接口上  
  | Liskov替换原则 | LSP，Liskov Substitution Principle | 子类必须能够替换其基类  
  | 合成/聚合利用原则 | CARP，Composite/Aggregate Reuse Principle | 在新对象中聚合已有对象，使之成为新对象的成员，从而通过操作这些对象达到利用的目的，合成方式较继承方式耦合更松散，所以应该少继承、多聚合  
  | 迪米物法则 | LoD，Law of Demeter | 又叫最少知道原则，指软件实体应该尽可能少的和其他软件实体产生相互作用  

* 单一职责建议  
  1. 一个类只有一个引起它变化的原因，否则就应当考虑重构  
  2. SRP由引起变化的原因决定，而不由功能职责决定。虽然职责常常是引起变化的轴线，但是有时却未必，应该审时度势  
  3. 测试驱动开发，有助于实现合理分离功能的设计  
  4. 可能通过Facade模式或Proxy模式进行职责分离  
   
* 开放封闭建议  
  1. 开放封闭原则，是最为重要的设计原则，Liskov替换原则和合成/聚合利用原则为开放封闭原则的实现提供保证  
  2. 可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭、对扩展开放的设计思路  
  3. 封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态一般将其封装为一个抽象  
  4. 拒绝滥用抽象，只将经常变化的部分进行抽象，这种经验可以从设计模式的学习与应用中获得  

*  依赖倒置建议  
    1. 抽象的稳定性决定了系统的稳定性，因为抽象是保持不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心思想  
    2. 依赖于抽象是一个通用的规则，而某些时候依赖于细节是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一成不变的  
    3. 依赖于抽象，就是要对接口编程，不要对实现编程  

* 接口隔离建议  
  1. 将功能相近的接口合并，可能造成接口污染，实现内聚的接口才是接口设计的基本原则  
  2. 接口隔离原则，能够保证系统扩展和修改的影响不会扩展到系统的其他部分，一定程序上保证了对开放封闭原则的遵守  

* Liskov替换建议  
  1. Liskov 替换原则是关于继承机制的设计原则，违反了Liskov 替换原则就必然导致违反开放封闭原则  
  2. Liskov 替换原则能够保证系统具有良好的雇工性，同时实现了基于态的抽象机制，能够减少代码冗余，避免运行期的类型判别  
  3. 子类必须满足基类和客户端对其的行为约定，客户端对行为的期望在基类和子类必须保持一致  
  4. IS-A 是基于行为方式的，它依赖于客户端的调用方式，对象的行为方式才是值得关注的要素  
  5. 子类的异常必须控制在父类可能预计的范围，否则将导致替换违规，违反了Liskov 替换原则  

---

* 为什么要依赖倒置  
  1. 依赖倒置是保证开放封闭的前提和基础  
  2. 依赖倒置是对抽象和依赖的基本原则和基本思想的哲学阐释  
  3. 依赖倒置是框架设计的核心思想  
  4. 依赖倒置是控制反转和依赖注入的思想基础  

* 控制反转，简言之就是代码的控制器交由系统控制，而不是在代码内部，通过IoC，消除组件或者模块间的直接依赖，使得软件系统的开发更具柔性和扩展性  
* 依赖注入，客户类依赖于服务类的抽象接口，并在运行时根据上下文环境，由其他组件实例化具体的服务类实例，将其注入到客户类的运行时环境，实现客户类与服务类实例之间松散的耦合关系 
* 依赖注入的方法  
  1. 接口注入，将对象间的关系转移到一个接口，以接口注入实例  
  2. 构造器注入，客户类在类型构造时，将服务类实例以构造函数参数的形式传递给客户端，因此服务类实例一旦注入将不可修改  
  3. 属性注入，通过客户类属性设置的方式，将服务器类实例在运行时设定为客户类属性，相较构造器注入方式，属性注入提供了改写服务类实例的可能  
  4. .NET平台中，一种更优雅的选择是使用 Attribute  

* 依赖注入框架，Unity、ObjectBuilder、Castle、Sprint.NET  
  
* 典型的设计模式  
  | 类别 | 依赖 | 模式 
  | :- | :- | :- 
  | 创建型模式 | 创建型模式的核心关注点就在于对象创建的依赖关系上，将对象的依赖从new操作中解脱出来，隔离应用系统和类型实例化间的依赖 | 工厂方法、抽象工厂、单例、创建者、原型模式 
  | 结构型模式 | 结构型模式，是将简单类型组合为复杂类型的过程，通过灵活的设计要素，最终保证不同类型间保持尽量间接的引用和尽量松散的耦合，在复杂类型有更多变化与诉求时，以最小的代价兼容变化，扩展诉求 | 桥接、适配器、组合、外观、装饰、享元、代理 
  | 行为型模式 | 行为型模式，关注对象行为的扩展和对象间数据关系的通信，以面向对象方式描述控制流 |模板方法、迭代器、中介者、职责链、解释器、命令、观察者、备忘录、状态、策略、访问者 

* 一点总结  
  1. 以new创建对象，是对依赖倒置原则的典型违反，可能通过工厂模式或者依赖注入来解决  
  2. 一个对象持有另外一个具体对象的引用可能破坏了依赖倒置  
  3. 所有结构良好的面向对象架构都具有清晰的层次定义，每个层次通过一个定义良好的受控接口向外提供一组内聚的服务  
  4. 依赖倒置预示着程序中的依赖关系不应是具体的类型，而应是抽象类和接口  
  5. 依赖倒置适用于当一个类向另一个类发送消息的任何情况  

| 模式名称 | 模式起点 | 典型应用 
| :- | :- | :- 
| 工厂方法(Factory Method Pattern) | 将程序中创建对象的操作单独进行处理，大大提高了系统扩展的柔性，接口的抽象化处理给互相依赖的对象创建提供了最好的抽象模式 | 工厂方法模式是最简单也最容易理解的模式之一。其关注的核心是对于对象创建这件事儿的分离 
| 单例(Singleton Pattern) | 一个类只有一个实例，且提供了一个访问全局点的方式，更加灵活保证了实例的创建和访问约束，并且唯一约束的实施由类本身实现 | 一个类只有一个实例，经常被应用于Facade模式，称为单例外观 
| 命令(Command Pattern) | 将请求封装为对象，从而将命令的执行和责任分开。通常在队列中等待命令 | 菜单系统 
| 策略(Strategy Pattern) | 将易于变化的部分封装为接口，通常Strategy封装一些运算法则，使之能互换 | 数据层常考虑以策略提供算法和数据的分离 
| 迭代器(Iterator Pattern) | 提供一种方法访问容器对象中各个元素，而又无需暴露该对象的内部细节 | .NET中就是应用了迭代器来创建用于foreach的集合 
| 模板方法(Template Method Pattern) | 就是在父类中定义模板，然后由子类实现 | ASP.NET的Page类
| 观察者(Observer Pattern) | 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新 | 在.NET中使用委托和事件可以更好地实现观察者模式 
| 职责链(Chain of Responsibility Pattern) | 将操作组成一个链表，通过遍历操作链表找到合适的处理器。通过统一的接口，被多个处理器实现，每个处理器都有后继处理器，可以将请求沿着处理器链传递 | GUI系统的事件传播 
| 桥接(Bridge Pattern) | 把实现和逻辑分开 | 多版本.NET Framework通过环境变量与对应版本应用建立桥梁 
| 代理(Proxy Pattern) | 将复杂的逻辑封装起来，通过代理对象控制实际对象的创建和访问，由代理对象屏蔽原有逻辑的复杂性，同时控制其可访问性 | WCF服务代理 
| 装饰器(Decorator Pattern) | 为原有系统，动态地增加或者删除状态和行为，在继承被装饰类的同时包含被装饰类的实例成员 | .NET中 Stream的设计 
| 门面(Facade Pattern) | 将表现层和逻辑层隔离，封装底层的复杂处理，为用户提供简单的接口 | WSDL就是一个典型的平台无关的门面应用 
| 组合(Composite Pattern) | 不管是个体还是组件，都包含公共的操作接口，通过同样的方式来处理一个组合中的所有对象组件的典型操作包括：增加、删除、查找、分组和获取子元素等 | 树形结构的数据组织 
| 适配器(Adapter Pattern) | 在原类型不做任何改变的情况下，扩展了新的接口，灵活且多样地适配一切旧俗 | RCW在COM Interop中的应用 

* 基于对象，就是一种对数据类型的抽象，封装一个结构包含了数据和函数，然后对对象为目标进行操作，不具有继承特性，也无多态，基于对象的语言特性就是将属性或方法，包含在以对象为结构的组织中

---



