---
layout: post
title: 你必须知道的.NET(第二版)
description: 一本介绍.NET核心技术的书，注：不太适合新手阅读
category: blog
subtype: read  
---

## 你必须知道的.NET-读书笔记
* 对象分为`值类型`和`引用类型`两种，其依据是对象在运行时在内存中的位置，值类型位于线程的`堆栈`，而引用类型位于`托管堆`。

* 值类型与引用类型的转变分别叫`装箱`和`拆箱`。

* 访问修饰符  

  | 访问修饰符 | 访问权限  
  | :- | :-  
  | public | 对访问成员没有限制，属于最高级别访问权限  
  | protected | 访问包含类或者从包含类派生的类  
  | internal | 访问仅限于程序集  
  | protected internal | 访问仅限于从包含类派生的当前程序集或类型。也就是同一个程序集的对象，或者该类及其子类可以访问  
  | private | 访问仅限于包含类型  

* 对象中的多态主要有以下两种情况  
  1.接口实现多态  
  2.抽象类实现多态  

* 继承，就是面向对象中类与类之间的关系。继承的类称为子类、派生类，而被继承类称为父类、基类或超类。通过继承，使得子类具有父类的属性和方法，同时子类也可以通过加入新的属性和方法或修改父类的属性和方法建立新的类层次。CLR支持实现单继承和接口多继承。  

* 继承的本质  
  1. 继承是可传递的，子类是对父类的扩展，必须继承父类方法，同时可以添加新方法  
  2. 子类可以调用父类方法和字段，而父类不能调用子类方法和字段  
  3. 虚方法如何实现覆写操作，使得父类指针可以指向子类对象成员
  4. 子类不光继承父类的公有成员，同时继承了父类的私有成员，只是在子类中不被访问  
  5. new 关键字在虚方法继承中的阻断作用  
   
* 抽象类与接口的对比  
  1. 抽象类适合于有族层概念的类间关系，而接口最适合为不同的类提供通用功能  
  2. 接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系  
  3. 接口多定义对象的行为；抽象类多定义对象的属性  
  4. 如果预计会出现版本问题，可以创建“抽象类”  
  5. 因为值类型是密封的，所以只能实现接口，而不能继承类  


* 继承的毒瘤主要体现在  
  1. 继承可能造成子类的无限膨胀，不利于类体系的维护和安全  
  2. 继承的子类对象确定于编译期，无法满足需要运行期才确定的情况，而类聚合很好地解决了这一问题  
  3. 随着继承层次的复杂化和子类的多样化，不可避免地会出现对父类的无效继承或者有害继承


* 继承的规则  
  1. 密封类不可以被继承  
  2. 继承关系中，我们更多的是关注其共性而不是特性，因为共性是层次复用的基础，而特性是系统扩展的基点  
  3. 实现单继承，接口多继承  
  4. 从宏观来看，继承多关注于共性；而多态多着眼于差异性  
  5. 继承的层次应该有所控制，否则类型之间的关系继护会消耗更多的精力  
  6. 面向对象原则：多组合，少继承；低耦合，高内聚  



